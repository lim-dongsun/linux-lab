# 🕒 5. 권한, 프로세스, screen 실습 

## 🎯 목표

리눅스에서 **파일 권한, 프로세스 확인/관리, 백그라운드 실행, nohup, screen** 등을 익히고  
실제 서버 환경에서 사용하는 프로세스 관리 능력을 기른다.

* * *

# 💻 실습

## 🧩 실습 1 — 파일 권한 확인 (ls -l)

```bash
ls -l
```

* * *

## 🧩 실습 2 — 권한 변경 (chmod)

```bash
# TODO: script.sh 생성
chmod +x script.sh
chmod 755 script.sh
```

<br>

* * *

## 🧩 실습 3 — 파일/폴더 소유자 변경 (chown)

```bash
chown root:root test.txt
```

* * *

## 🧩 실습 4 — 현재 실행 중인 프로세스 확인 (ps / top)

### 전체 프로세스 보기

```bash
ps aux
```

### ps aux 샘플 출력

```
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root       101  0.3  1.2  56780  5120 pts/0    Ss   10:22   0:00 -bash
root       214  0.0  0.8  45000  3200 pts/0    S    10:25   0:00 bash script.sh
root       380  0.1  0.7  41200  2900 pts/1    Ss   10:26   0:00 bash
root       455  0.0  0.4  35000  1800 pts/2    S    10:26   0:00 grep bash
```

### ps aux 컬럼 설명

| 컬럼  | 의미  |
| --- | --- |
| USER | 실행 사용자 |
| PID | 프로세스 ID |
| %CPU | CPU 사용률 |
| %MEM | 메모리 사용률 |
| VSZ | 가상 메모리 크기 |
| RSS | 실제 메모리 사용량 |
| TTY | 실행 중인 터미널 |
| STAT | 프로세스 상태 |
| START | 시작 시간 |
| TIME | 누적 CPU 시간 |
| COMMAND | 실행 명령어 |

* * *

## 🧩 실습 5 — ps -ef + grep 실습

### 명령어

```bash
ps -ef | grep bash
```

### ps -ef 샘플 출력

```
root        1123    1087  0 10:22 pts/0    00:00:00 -bash
root        2144    1123  0 10:25 pts/0    00:00:00 bash script.sh
root        2890    1888  0 10:26 pts/1    00:00:00 bash
root        3012    2451  0 10:26 pts/2    00:00:00 grep bash
```

### ps -ef 컬럼 설명

| 컬럼  | 의미  |
| --- | --- |
| UID | 실행 사용자 |
| PID | 프로세스 ID |
| PPID | 부모 프로세스 ID |
| C   | CPU 사용량 (%) |
| STIME | 시작 시간 |
| TTY | 실행 중인 터미널 |
| TIME | 누적 CPU 시간 |
| CMD | 실행된 전체 명령어 |

* * *

## 🧩 실습 6 — 백그라운드 실행 (&)

먼저 **백그라운드 실행**을 경험해 봅니다.

```bash
sleep 30 &
```

백그라운드 작업 목록 확인:

```bash
jobs
```

`ps`로도 확인:

```bash
ps -ef | grep sleep
```

* * *

## 🧩 실습 7 — 프로세스 종료 (kill)

앞에서 백그라운드로 실행한 프로세스를 종료해 봅니다.

PID 찾기:

```bash
ps -ef | grep sleep
```

종료:

```bash
kill <PID>
```

강제 종료(필요할 때만):

```bash
kill -9 <PID>
```

* * *

# ⚠️ 중요한 주의 사항

## ❌ kill -9 남용 금지

- `kill -9`는 강제 종료로, 데이터 손실 가능
- 항상 `kill <PID>`부터 시도하세요.

* * *

## 🧩 실습 8 — 5초마다 로그를 쓰는 스크립트 + tail 모니터링

### 스크립트 생성

```bash
cat << 'EOF' > log_writer.sh
#!/bin/bash
while true
do
  echo "$(date) - system running..." >> system_loop.log
  sleep 5
done
EOF
```

실행 권한:

```bash
chmod +x log_writer.sh
```

백그라운드 실행:

```bash
./log_writer.sh &
```

로그 실시간 확인:

```bash
tail -f system_loop.log
```

종료:

```
# tail 종료
Ctrl + C
# TODO: log_writer.sh 종료
```

* * *

## 🧩 실습 9 — nohup + 백그라운드 실행

### nohup 이란?

- 터미널을 닫거나 로그아웃해도 **프로세스가 종료되지 않도록** 해주는 명령입니다.
- 기본적으로 **SIGHUP(세션 종료 시그널)을 무시**하도록 만들어 줍니다.
- 표준 출력은 보통 `nohup.out` 파일로 저장됩니다.

### 예제

```bash
nohup ./log_writer.sh &
tail -f nohup.out
```

* * *

# 📦 참고 — nohup 메시지가 왜 뜨는가?

```
nohup: ignoring input and appending output to 'nohup.out'
```

이 메시지는 **정상적인 동작**이다.

- **ignoring input** : nohup은 세션 종료 시 영향을 받지 않도록 STDIN을 무시함
- **appending output to nohup.out** : stdout/stderr을 nohup.out로 저장함
- nohup 이 입력을 무시하고(STDIN) 출력(stdout, stderr)을 nohup.out에 저장하고 있다는 뜻.

* * *

# 📦 참고 — 리다이렉션 설명

```bash
nohup ./log_writer.sh > mylog.log 2>&1 &
```

<br>

| 구문  | 설명  |
| --- | --- |
| `>` | stdout 덮어쓰기 |
| `>>` | stdout 이어쓰기 |
| `2>` | stderr 리다이렉트 |
| `2>&1` | stderr → stdout 방향 합치기 |
| `&` | 백그라운드 실행 |

- `> mylog.log`: stdout은 mylog.log로 저장
- `2>&1`  : stderr도 stdout의 목적지(mylog.log)에 합류
- `&`  : 백그라운드 실행
- stdout + stderr 모두 mylog.log에 저장됨.

<br>

* * *

## 🧩 실습 10 — screen 사용법

### screen 설치

```bash
apt update && apt install -y screen
```

### 세션 생성

```bash
screen -S mysession
```

### 세션 분리(detach)

```
Ctrl + A, D
```

### 세션 목록

```bash
screen -ls
```

### 세션 재접속

```bash
screen -r mysession
```

### 세션 종료

screen 내부에서:

```bash
exit
```

* * *

## 🧩 실습 11 — screen × ps × tail 연계 실습

```bash
screen -S logsession
./log_writer.sh

# 여기서 detach
Ctrl + A, D

tail -f system_loop.log

screen -r logsession

ps -ef | grep log_writer

kill <PID>
```

* * *

# 📘 screen vs nohup 비교

| 기능/특징 | **screen** | **nohup** |
| --- | --- | --- |
| 목적  | 터미널 세션 전체 유지 | 개별 명령어를 세션 종료 후에도 유지 |
| 실행 형태 | 독립된 가상 터미널 제공 | 기존 셸에서 명령어만 보호 |
| 재접속 | ✔ `screen -r` 로 가능 | ✖ 직접 재접속 불가 (로그만 확인) |
| 상호작용 | 상호작용 가능(vi, REPL 등) | 보통 비상호작용(배치 작업) |
| 화면 확인 | 직접 접속하여 화면 확인 | `nohup.out` 등 로그 파일로 확인 |
| 여러 작업 관리 | 여러 세션 관리 가능 | 각 명령어별로 nohup 실행 필요 |
| 대표 사용 예 | 장시간 편집, 디버깅, REPL, 실시간 모니터링 | 배치 작업, 스크립트 실행, 단발성 작업 |

* * *

# 📘 백그라운드 실행(&) vs nohup 비교

| 항목  | `command &` (백그라운드) | `nohup command &` |
| --- | --- | --- |
| 터미널 종료 시 | 프로세스가 **종료될 수 있음** (SIGHUP 전송) | 프로세스가 **계속 실행**됨 (SIGHUP 무시) |
| 실행 위치 | 현재 셸 세션에 종속 | 세션 종료에도 비교적 독립적 |
| 표준 출력 | 터미널로 출력(또는 리다이렉션 필요) | 기본적으로 `nohup.out`에 저장 |
| 용도  | 잠깐 백그라운드에 돌리고 같은 세션에서 관리 | 서버에서 장시간 돌릴 작업, 세션 끊겨도 유지해야 할 작업 |
| 사용 난이도 | 매우 쉬움 | 약간 더 개념적이지만 명령은 간단 |

* * *

# 🎯 추가 실습

```
1) sleep 100 을 & 로 실행하고, ps -ef | grep 으로 PID를 찾아 kill 해보세요.  
2) log_writer.sh를 nohup 으로 실행해보고, 터미널을 종료/재접속한 뒤에도 살아있는지 확인해보세요.  
3) 같은 작업을 screen 세션 안에서 실행한 뒤, detach/reattach 를 반복해보세요.
```